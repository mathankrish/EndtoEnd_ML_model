# -*- coding: utf-8 -*-
"""credit_risk_analysis_final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NUrr0VgiJypkp-WZwQNTtixkGNIWpDyo
"""

# import necessary packages
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn.pipeline import make_pipeline
from sklearn.metrics import accuracy_score, f1_score, classification_report, confusion_matrix
from sklearn import metrics
from google.cloud import storage
from joblib import dump
from sklearn.model_selection import train_test_split
from sklearn.cluster import KMeans

df = pd.read_csv("/content/loan.csv")
df.head()

df.info()

def load_data(filename):
  df = pd.read_csv(filename)
  return df

def preprocess(df):
  # Apply label encoding to all columns
  df.drop(df.columns.difference(['loan_amnt','term','int_rate','installment','grade','emp_length','home_ownership',
                                         'annual_inc','verification_status','loan_status','purpose',]),axis= 1, inplace=True)

  label_categories = [
    (0, ['Fully Paid', 'Does not meet the credit policy. Status:Fully Paid', 'Current']),
    (1, ['Late (31-120 days)', 'Late (16-30 days)', 'In Grace Period',
         'Charged Off', 'Default', 'Does not meet the credit policy. Status:Charged Off'])
]

  # function to apply the transformation
  def classify_label(text):
      for category, matches in label_categories:
          if any(match in text for match in matches):
              return category
      return None

  df.loc[:, 'label'] = df['loan_status'].apply(classify_label)
  df = df.drop('loan_status', axis=1)

  def SC_LabelEncoder1(text):
    if text == "E":
        return 1
    elif text == "D":
        return 2
    elif text == "C":
        return 3
    elif text == "B":
        return 4
    elif text == "A":
        return 5
    else:
        return 0


  def SC_LabelEncoder2(text):
      if text == "< 1 year":
          return 1
      elif text == "1 year":
          return 2
      elif text == "2 years":
          return 3
      elif text == "3 years":
          return 4
      elif text == "4 years":
          return 5
      elif text == "5 years":
          return 6
      elif text == "6 years":
          return 7
      elif text == "7 years":
          return 8
      elif text == "8 years":
          return 9
      elif text == "9 years":
          return 10
      elif text == "10 years":
          return 11
      elif text == "10+ years":
          return 12
      else:
          return 0

  def SC_LabelEncoder3(text):
      if text == "RENT":
          return 1
      elif text == "MORTGAGE":
          return 2
      elif text == "OWN":
          return 3
      else:
          return 0

  df["grade"] = df["grade"].apply(SC_LabelEncoder1)
  df["emp_length"] = df["emp_length"].apply(SC_LabelEncoder2)
  df["home_ownership"] = df["home_ownership"].apply(SC_LabelEncoder3)
  # df = df.apply(LabelEncoder().fit_transform)
  for col in ["verification_status", "purpose","term"]:
    le = LabelEncoder()
    le.fit(df[col])
    df[col] = le.transform(df[col])

  return df

def clustering(df):
  km = KMeans(n_clusters=4, random_state=0)
  clusters = km.fit_predict(df)
  df["Cluster"] = clusters
  x = df.drop("label", axis = 1)
  y = df["label"]
  return x, y

def train_model(x_train, y_train):

  model = RandomForestClassifier()
  pipeline = make_pipeline(model)
  pipeline.fit(x_train, y_train)
  return pipeline

def evaluate_model(model, x_train, y_train, x_test, y_test):


  pred_proba = model.predict_proba(x_test)[:, 1]
  ypred = model.predict(x_test)

  print(accuracy_score(ypred, y_test))
  print(classification_report(ypred, y_test))
  print(confusion_matrix(ypred, y_test))


  # ROC Curve
  fpr, tpr, roc_thresholds = metrics.roc_curve(y_test, pred_proba)
  roc_auc = metrics.roc_auc_score(y_test, pred_proba)

  # Plotting ROC Curve
  fig, ax = plt.subplots(1, 1, figsize=(12, 5))

  ax.plot(fpr, tpr, label=f'{type}, ROC AUC={roc_auc:.2f}')
  ax.plot([0, 1], [0, 1], linestyle='--', color='grey')
  ax.scatter(fpr[1], tpr[1], color='red')
  ax.set_xlim([-0.02, 1.02])
  ax.set_ylim([-0.02, 1.02])
  ax.set_xlabel('False Positive Rate')
  ax.set_ylabel('True Positive Rate')
  ax.legend(loc='lower center')
  ax.set_title('ROC Curve')

  return

path = "/content/loan.csv"
df = load_data(path)
df1 = preprocess(df)
df1.fillna(1, inplace = True)
x, y = clustering(df1)
xtrain, xtest, ytrain, ytest = train_test_split(x, y, test_size = 0.2, random_state = 10, stratify = y)
model = train_model(xtrain, ytrain)
ypred = model.predict(xtest)
print(accuracy_score(ytest, ypred))
evaluate_model(model, xtrain, ytrain, xtest, ytest)

